# 보스 처치 후 엔딩 연출 기술 구현

## 1. 시스템 아키텍처

### 1.1 핵심 컴포넌트
```csharp
// 엔딩 연출 매니저
public class EndingCutsceneManager : MonoBehaviour
{
    [Header("연출 오브젝트")]
    public GameObject rescuePlanePrefab;
    public GameObject ropePrefab;
    
    [Header("연출 설정")]
    public float planeSpeed = 5f;
    public float ropeDropSpeed = 3f;
    public float rescueSpeed = 2f;
    
    private EndingState currentState;
    private GameObject activeRescuePlane;
    private GameObject activeRope;
}
```

### 1.2 상태 관리
```csharp
public enum EndingState
{
    WaitingForBossDefeat,
    PlaneApproaching,
    RopeDropping,
    PlayerRescue,
    Completed
}
```

## 2. 구현 단계별 세부사항

### 2.1 보스 처치 감지
```csharp
// BossController에서 호출
private void OnBossDefeated()
{
    // 2초 대기 후 엔딩 연출 시작
    StartCoroutine(DelayedEndingStart());
}

private IEnumerator DelayedEndingStart()
{
    yield return new WaitForSeconds(2f);
    EndingCutsceneManager.Instance.StartEndingCutscene();
}
```

### 2.2 비행기 등장 시스템
```csharp
private IEnumerator SpawnAndMoveRescuePlane()
{
    // 화면 상단 랜덤 위치에서 비행기 생성
    Vector3 spawnPos = new Vector3(
        playerTransform.position.x + Random.Range(-10f, 10f),
        Camera.main.ViewportToWorldPoint(new Vector3(0.5f, 1.2f, 0)).y,
        0
    );
    
    activeRescuePlane = Instantiate(rescuePlanePrefab, spawnPos, Quaternion.identity);
    
    // 플레이어 위치로 이동
    Vector3 targetPos = new Vector3(playerTransform.position.x, 
                                   playerTransform.position.y + 8f, 0);
    
    while (Vector3.Distance(activeRescuePlane.transform.position, targetPos) > 0.5f)
    {
        activeRescuePlane.transform.position = Vector3.MoveTowards(
            activeRescuePlane.transform.position, 
            targetPos, 
            planeSpeed * Time.deltaTime
        );
        yield return null;
    }
    
    // 로프 투하 시작
    StartCoroutine(DropRope());
}
```

### 2.3 로프 시스템 (물리 기반)
```csharp
private IEnumerator DropRope()
{
    // 로프 생성 (LineRenderer + Rigidbody2D 체인)
    activeRope = CreatePhysicsRope(activeRescuePlane.transform.position);
    
    // 로프가 플레이어 근처에 도달할 때까지 대기
    yield return new WaitUntil(() => IsRopeNearPlayer());
    
    // 플레이어 구조 시작
    StartCoroutine(RescuePlayer());
}

private GameObject CreatePhysicsRope(Vector3 startPos)
{
    GameObject ropeParent = new GameObject("RescueRope");
    LineRenderer lineRenderer = ropeParent.AddComponent<LineRenderer>();
    
    // 로프 세그먼트 생성 (물리 시뮬레이션)
    List<GameObject> ropeSegments = new List<GameObject>();
    int segmentCount = 10;
    
    for (int i = 0; i < segmentCount; i++)
    {
        GameObject segment = new GameObject($"RopeSegment_{i}");
        segment.AddComponent<Rigidbody2D>();
        segment.AddComponent<CircleCollider2D>().radius = 0.1f;
        
        if (i > 0)
        {
            // HingeJoint2D로 세그먼트 연결
            HingeJoint2D joint = segment.AddComponent<HingeJoint2D>();
            joint.connectedBody = ropeSegments[i-1].GetComponent<Rigidbody2D>();
        }
        
        ropeSegments.Add(segment);
    }
    
    return ropeParent;
}
```

### 2.4 플레이어 구조 시스템
```csharp
private IEnumerator RescuePlayer()
{
    // 플레이어 입력 비활성화
    PlayerController.Instance.SetInputEnabled(false);
    
    // 플레이어를 로프에 부착
    AttachPlayerToRope();
    
    // UI 표시
    ShowRescueUI("구조 중...");
    
    // 비행기와 함께 위로 이동
    Vector3 exitPosition = new Vector3(
        activeRescuePlane.transform.position.x,
        Camera.main.ViewportToWorldPoint(new Vector3(0.5f, 1.5f, 0)).y,
        0
    );
    
    while (Vector3.Distance(activeRescuePlane.transform.position, exitPosition) > 0.5f)
    {
        activeRescuePlane.transform.position = Vector3.MoveTowards(
            activeRescuePlane.transform.position,
            exitPosition,
            rescueSpeed * Time.deltaTime
        );
        
        // 플레이어도 함께 이동
        playerTransform.position = GetRopeEndPosition();
        
        yield return null;
    }
    
    // 구조 완료
    CompleteRescue();
}

private void AttachPlayerToRope()
{
    // 플레이어를 로프 끝에 부착
    FixedJoint2D playerJoint = playerTransform.gameObject.AddComponent<FixedJoint2D>();
    playerJoint.connectedBody = GetRopeEndSegment().GetComponent<Rigidbody2D>();
    
    // 플레이어 애니메이션 변경
    PlayerAnimator.Instance.PlayAnimation("Hanging");
}
```

## 3. 오디오 시스템

### 3.1 효과음 관리
```csharp
[System.Serializable]
public class EndingAudioClips
{
    public AudioClip planeEngineSound;
    public AudioClip ropeDropSound;
    public AudioClip rescueCompleteSound;
    public AudioClip victoryMusic;
}

private void PlayEndingAudio(AudioClip clip, bool loop = false)
{
    AudioSource audioSource = GetComponent<AudioSource>();
    audioSource.clip = clip;
    audioSource.loop = loop;
    audioSource.Play();
}
```

## 4. 카메라 시스템

### 4.1 동적 카메라 추적
```csharp
private IEnumerator UpdateCameraForCutscene()
{
    CameraController cameraController = Camera.main.GetComponent<CameraController>();
    
    // 1단계: 플레이어 중심 고정
    cameraController.SetTarget(playerTransform, 2f);
    yield return new WaitForSeconds(2f);
    
    // 2단계: 비행기 포함하도록 확대
    cameraController.SetMultipleTargets(new Transform[] { 
        playerTransform, 
        activeRescuePlane.transform 
    });
    
    // 3단계: 구조 과정 추적
    while (currentState != EndingState.Completed)
    {
        cameraController.UpdateTargetPosition();
        yield return null;
    }
}
```

## 5. 파티클 효과

### 5.1 비행기 효과
```csharp
private void SetupPlaneEffects()
{
    // 프로펠러 바람 효과
    ParticleSystem windEffect = activeRescuePlane.GetComponentInChildren<ParticleSystem>();
    var main = windEffect.main;
    main.startLifetime = 1f;
    main.startSpeed = 5f;
    
    // 물보라 효과 (플레이어 구조 시)
    ParticleSystem splashEffect = Instantiate(splashParticlePrefab, 
                                            playerTransform.position, 
                                            Quaternion.identity);
}
```

## 6. 성능 최적화

### 6.1 메모리 관리
```csharp
private void CleanupCutsceneObjects()
{
    // 연출 완료 후 정리
    if (activeRescuePlane != null)
        Destroy(activeRescuePlane);
    
    if (activeRope != null)
        Destroy(activeRope);
    
    // 파티클 시스템 정리
    ParticleSystem[] particles = FindObjectsOfType<ParticleSystem>();
    foreach (var particle in particles)
    {
        if (particle.gameObject.name.Contains("Cutscene"))
            Destroy(particle.gameObject);
    }
}
```

### 6.2 프레임 최적화
```csharp
// 물리 계산 최적화
private void OptimizeRopePhysics()
{
    // 로프 세그먼트 수 동적 조정
    int segmentCount = Application.isMobilePlatform ? 6 : 10;
    
    // 물리 업데이트 빈도 조정
    Time.fixedDeltaTime = Application.isMobilePlatform ? 0.02f : 0.016f;
}
```

## 7. 디버깅 및 테스트

### 7.1 디버그 기능
```csharp
#if UNITY_EDITOR
[Header("디버그 설정")]
public bool skipToEnding = false;
public bool showGizmos = true;

private void OnDrawGizmos()
{
    if (showGizmos && activeRescuePlane != null)
    {
        // 비행기 경로 시각화
        Gizmos.color = Color.yellow;
        Gizmos.DrawWireSphere(activeRescuePlane.transform.position, 1f);
        
        // 로프 위치 시각화
        if (activeRope != null)
        {
            Gizmos.color = Color.brown;
            Gizmos.DrawLine(activeRescuePlane.transform.position, 
                           GetRopeEndPosition());
        }
    }
}
#endif
```

## 8. 통합 테스트 시나리오
1. **정상 시나리오**: 보스 처치 → 비행기 등장 → 로프 투하 → 구조 완료
2. **예외 시나리오**: 연출 중 앱 종료, 메모리 부족 상황
3. **성능 테스트**: 저사양 기기에서의 프레임 드롭 확인
4. **UI 테스트**: 다양한 해상도에서의 연출 확인 